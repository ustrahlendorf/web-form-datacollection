<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Page Integration Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .summary {
            font-size: 16px;
            font-weight: bold;
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
        }
        .summary-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .summary-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <h1>Form Page Integration Tests</h1>
    <p>Property 0: Form Pre-Population on Page Load</p>
    <p><strong>Validates: Requirements 2.2, 2.3, 2.4</strong></p>

    <div id="test-results"></div>
    <div id="summary"></div>

    <script>
        // Test utilities
        const tests = [];
        let passCount = 0;
        let failCount = 0;

        function addTest(name, testFn) {
            tests.push({ name, testFn });
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message);
            }
        }

        function assertEquals(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(`${message}\nExpected: ${expected}\nActual: ${actual}`);
            }
        }

        function assertMatches(actual, pattern, message) {
            if (!pattern.test(actual)) {
                throw new Error(`${message}\nExpected pattern: ${pattern}\nActual: ${actual}`);
            }
        }

        // Test: Date pre-population format
        addTest('Date pre-population should be in dd.mm.yyyy format', () => {
            const now = new Date();
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const year = now.getFullYear();
            const expectedDate = `${day}.${month}.${year}`;

            assertMatches(expectedDate, /^\d{2}\.\d{2}\.\d{4}$/, 'Date format should be dd.mm.yyyy');
        });

        // Test: Time pre-population format
        addTest('Time pre-population should be in hh:mm format', () => {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const expectedTime = `${hours}:${minutes}`;

            assertMatches(expectedTime, /^\d{2}:\d{2}$/, 'Time format should be hh:mm');
        });

        // Test: Numeric fields initialization
        addTest('Numeric fields should initialize to 0', () => {
            const betriebsstunden = '0';
            const starts = '0';
            const verbrauch_qm = '0';

            assertEquals(betriebsstunden, '0', 'betriebsstunden should be 0');
            assertEquals(starts, '0', 'starts should be 0');
            assertEquals(verbrauch_qm, '0', 'verbrauch_qm should be 0');
        });

        // Test: Date formatting with leading zeros
        addTest('Date formatting should handle single-digit days and months', () => {
            const testDate = new Date(2025, 0, 5); // January 5, 2025
            const day = String(testDate.getDate()).padStart(2, '0');
            const month = String(testDate.getMonth() + 1).padStart(2, '0');
            const year = testDate.getFullYear();
            const formatted = `${day}.${month}.${year}`;

            assertEquals(formatted, '05.01.2025', 'Date should have leading zeros');
        });

        // Test: Time formatting with leading zeros
        addTest('Time formatting should handle single-digit hours and minutes', () => {
            const testDate = new Date(2025, 11, 15, 5, 3);
            const hours = String(testDate.getHours()).padStart(2, '0');
            const minutes = String(testDate.getMinutes()).padStart(2, '0');
            const formatted = `${hours}:${minutes}`;

            assertEquals(formatted, '05:03', 'Time should have leading zeros');
        });

        // Test: Date validation function
        addTest('Date validation should accept valid dates', () => {
            function isValidDate(dateStr) {
                const regex = /^(\d{2})\.(\d{2})\.(\d{4})$/;
                const match = dateStr.match(regex);
                
                if (!match) return false;
                
                const day = parseInt(match[1]);
                const month = parseInt(match[2]);
                const year = parseInt(match[3]);
                
                const date = new Date(year, month - 1, day);
                return date.getFullYear() === year && 
                       date.getMonth() === month - 1 && 
                       date.getDate() === day;
            }

            assert(isValidDate('15.12.2025'), 'Valid date should be accepted');
            assert(isValidDate('01.01.2025'), 'Valid date with leading zeros should be accepted');
            assert(!isValidDate('31.02.2025'), 'Invalid date should be rejected');
            assert(!isValidDate('invalid'), 'Malformed date should be rejected');
        });

        // Test: Time validation function
        addTest('Time validation should accept valid times', () => {
            function isValidTime(timeStr) {
                const regex = /^(\d{2}):(\d{2})$/;
                const match = timeStr.match(regex);
                
                if (!match) return false;
                
                const hours = parseInt(match[1]);
                const minutes = parseInt(match[2]);
                
                return hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59;
            }

            assert(isValidTime('09:30'), 'Valid time should be accepted');
            assert(isValidTime('00:00'), 'Midnight should be accepted');
            assert(isValidTime('23:59'), 'Last minute of day should be accepted');
            assert(!isValidTime('25:00'), 'Invalid hour should be rejected');
            assert(!isValidTime('12:60'), 'Invalid minute should be rejected');
            assert(!isValidTime('invalid'), 'Malformed time should be rejected');
        });

        // Test: Decimal normalization
        addTest('Decimal normalization should convert comma to dot', () => {
            function normalizeDecimal(value) {
                return value.replace(',', '.');
            }

            assertEquals(normalizeDecimal('19,5'), '19.5', 'Comma should be converted to dot');
            assertEquals(normalizeDecimal('0,01'), '0.01', 'Comma should be converted to dot');
            assertEquals(normalizeDecimal('19.5'), '19.5', 'Dot should be preserved');
        });

        // Test: Whitespace trimming
        addTest('Whitespace trimming should remove leading and trailing spaces', () => {
            function trimWhitespace(value) {
                return value.trim();
            }

            assertEquals(trimWhitespace('  15.12.2025  '), '15.12.2025', 'Leading and trailing spaces should be removed');
            assertEquals(trimWhitespace('  09:30  '), '09:30', 'Leading and trailing spaces should be removed');
            assertEquals(trimWhitespace('15.12.2025'), '15.12.2025', 'No spaces should be preserved');
        });

        // Run all tests
        function runTests() {
            const resultsDiv = document.getElementById('test-results');
            
            tests.forEach(test => {
                try {
                    test.testFn();
                    passCount++;
                    const result = document.createElement('div');
                    result.className = 'test-result test-pass';
                    result.textContent = `✓ ${test.name}`;
                    resultsDiv.appendChild(result);
                } catch (error) {
                    failCount++;
                    const result = document.createElement('div');
                    result.className = 'test-result test-fail';
                    result.textContent = `✗ ${test.name}\n${error.message}`;
                    resultsDiv.appendChild(result);
                }
            });

            // Display summary
            const summaryDiv = document.getElementById('summary');
            const summaryClass = failCount === 0 ? 'summary-pass' : 'summary-fail';
            summaryDiv.className = `summary ${summaryClass}`;
            summaryDiv.textContent = `Tests: ${passCount} passed, ${failCount} failed (Total: ${tests.length})`;
        }

        // Run tests when page loads
        window.addEventListener('load', runTests);
    </script>
</body>
</html>
